# ========= Services ==========

# here we can define services, or limits for services, as meta-data

sla_service_up{cl_cd_swarm_service_name="cloudstack_rabbitmq",cl_cd_stack_namespace="cloudstack"}=1.0
sla_service_up{cl_cd_swarm_service_name="cloudstack_mymongodb",cl_cd_stack_namespace="cloudstack"}=1.0
# here i could say for example, an availability of 0,7 is totally ok
# since the messages will be collected eventually 
sla_service_up{cl_cd_swarm_service_name="cloudstack_rabbit2mongo",cl_cd_stack_namespace="cloudstack"}=0.7

# ========= RAM, JVM-Memory ==============

container_memory_percent=container_memory_usage_bytes / container_spec_memory_limit_bytes
jvm_memory_bytes_percent=jvm_memory_bytes_used / jvm_memory_bytes_max

# ========= CPU ==========================

#throttled seconds, per second considering the last 5 minutes (1=full stop)
container_cpu_throttle_seconds_rate=rate(container_cpu_cfs_throttled_seconds_total[5m])
#if throttled more than 10% of the time then we have a hotspot (especially if over some time)
container_cpu_throttle_hotspot=container_cpu_throttle_seconds_rate >bool 0.1
# how many are have a throttle-hotspot (can be grouped in influx+grafana)
container_cpu_throttle_hotspot_percent=sum(container_cpu_throttle_hotspot) / count(container_cpu_cfs_throttled_seconds_total)
# what percentage of its spec periods does a task get
container_cpu_period_percent=container_cpu_cfs_periods_total / container_spec_cpu_period

# ======== Disk ==========================

#container disk storage predicted in 4 hours
container_fs_bytes_left_in4h=container_fs_limit_bytes - predict_linear(container_fs_usage_bytes[1h], 60*60*4)

# ======== Network =======================

# we set limits for the network speed. a definition like this can be used 
# either as upper or lower limit. The enforcement of the limit is up to the
# provider of course, we just want to monitor if the network-bandwith
# we ordered fits our needs. When we set our limit just shy below the
# actual limit as ordered from a provider we can 

# another example
#		consider we have a metrics about the expected data rate at which we produce 
#		data. we can calculate a metrics as to how far we achieve the specified throughput 
#		for the slice e.g. we ordered 10 MB/s, our sensors produce 8 MB/s but we only
#		achieve 5 MB/s. Of course this can have multiple reasons but network-congestion
#		could be one of them. 
slice_network_limit_bytespersecond{cl_cd_stack_namespace="cloudstack"} = 100000.0
slice_network_limit_bytespersecond{cl_cd_stack_namespace="nfvstack"} = 10000.0
slice_network_limit_bytespersecond{cl_cd_stack_namespace="iotstack"} = 1000.0

container_network_transmit_bytes_sumtotal=sum(container_network_transmit_bytes_total) by (cl_cd_stack_namespace, cl_cd_swarm_service_name)
container_network_transmit_bytes_percent=rate(container_network_transmit_bytes_sumtotal[2m])  / ignoring(cl_cd_swarm_service_name)  group_left(cl_cd_stack_namespace) slice_network_limit_bytespersecond

container_network_receive_bytes_sumtotal=sum(container_network_receive_bytes_total) by (cl_cd_stack_namespace, cl_cd_swarm_service_name)
container_network_receive_bytes_percent=rate(container_network_receive_bytes_sumtotal[2m])  / ignoring(cl_cd_swarm_service_name)  group_left(cl_cd_stack_namespace) slice_network_limit_bytespersecond

# ======= Availability ===============

# we need to round otherwise there can be values like 0.99999993434 because 
#	same with clamp_max. 
# internally double is used. 
# this gives us the availability on an _instance level_
instance_availability_1min=clamp_max(round(rate(container_last_seen[1m]), 0.0009), 1.0)
instance_availability_5min=clamp_max(round(rate(container_last_seen[5m]), 0.0009), 1.0)
instance_availability_15min=clamp_max(round(rate(container_last_seen[15m]), 0.0009), 1.0)
instance_availability_60min=clamp_max(round(rate(container_last_seen[60m]), 0.0009), 1.0)

# on the _sub-slice level_ we must consider that some services may
# be run in replicated mode, so there is more than one instance and
# as long as 1 instance (or maybe a specified number of instances)
# is in service it is available
service_availability_1m=sum(instance_availability_1min) by (cl_cd_swarm_service_name, cl_cd_stack_namespace)
service_availability_5m=sum(instance_availability_5min) by (cl_cd_swarm_service_name, cl_cd_stack_namespace)
service_availability_15m=sum(instance_availability_15min) by (cl_cd_swarm_service_name, cl_cd_stack_namespace)
service_availability_60m=sum(instance_availability_60min) by (cl_cd_swarm_service_name, cl_cd_stack_namespace)

# finally we compare the sla with the availability
# so we get 0.0s for services which are down
service_slaavailability_1m=clamp_max(service_availability_1m /  ignoring(cl_cd_stack_namespace) group_right(cl_cd_swarm_service_name) sla_service_up, 1) or (sla_service_up-sla_service_up)
service_slaavailability_5m=clamp_max(service_availability_5m /  ignoring(cl_cd_stack_namespace) group_right(cl_cd_swarm_service_name) sla_service_up, 1) or (sla_service_up-sla_service_up)
service_slaavailability_15m=clamp_max(service_availability_15m /  ignoring(cl_cd_stack_namespace) group_right(cl_cd_swarm_service_name) sla_service_up, 1) or (sla_service_up-sla_service_up)
service_slaavailability_60m=clamp_max(service_availability_60m /  ignoring(cl_cd_stack_namespace) group_right(cl_cd_swarm_service_name) sla_service_up, 1) or (sla_service_up-sla_service_up)

# on the _sub-slice_ we can group by the stack (or env) and use min() to determine the health
# same on the _full slice_
# other options ??? 

# === Application Metrics ===
#The following example expression returns the difference in CPU temperature between now and 2 hours ago
#delta(cpu_temp_celsius{host="zeus"}[2h])